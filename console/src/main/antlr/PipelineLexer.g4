lexer grammar PipelineLexer;
import KnolusLexer;

SINGLE_LINE_COMMENT: '//' ~[\n]+ NEW_LINE* -> skip;
MULTI_LINE_COMMENT: '/*' .*? '*/' NEW_LINE* -> skip ; // .*? matches anything until the first */

CALL_SCRIPT: SCRIPT_LIST INLINE_WHITESPACE_CHARACTERS+ -> pushMode(ScriptCall);

BEGIN_FUNCTION_CALL: IDENTIFIER_START IDENTIFIER_END* '(' -> pushMode(FunctionCall);
BEGIN_MEMBER_REFERENCE: IDENTIFIER_START IDENTIFIER_END* '.';

GLOBAL_IDENTIFIER: IDENTIFIER_START IDENTIFIER_END* -> type(IDENTIFIER);

fragment NEW_LINE: '\r'? '\n';
fragment SCRIPT_LIST
    : E X T R A C T (SWS) F I L E S
    | E X T R A C T (SWS) F I L E S (SWS) W I Z A R D
    | S H O W (SWS) E N V (I R O N M E N T)?
    ;

SKIP_WS: INLINE_WHITESPACE_CHARACTERS+ -> skip;

fragment SWS: INLINE_WHITESPACE_CHARACTERS*;

mode ScriptCall;

SCRIPT_CALL_INTEGER: INTEGER -> type(INTEGER);
SCRIPT_CALL_DECIMAL_NUMBER: DECIMAL_NUMBER -> type(DECIMAL_NUMBER);

SCRIPT_CALL_NULL: NULL -> type(NULL);
SCRIPT_CALL_BEGIN_QUOTED_STRING: '"' -> type(BEGIN_QUOTED_STRING), pushMode(QuotedStringMode);
SCRIPT_CALL_TRUE: TRUE -> type(TRUE);
SCRIPT_CALL_FALSE: FALSE -> type(FALSE);
SCRIPT_CALL_START_EXPRESSION: '(' -> type(BEGIN_EXPRESSION), pushMode(ExpressionMode);

SCRIPT_CALL_RECURSIVE: '$(' -> pushMode(DEFAULT_MODE);

SCRIPT_CALL_PARAM_SEPARATOR: INLINE_WHITESPACE_CHARACTERS+;

SCRIPT_CALL_FUNCTION_CALL: IDENTIFIER_START IDENTIFIER_END* '(' -> type(BEGIN_FUNCTION_CALL), pushMode(FunctionCall);
SCRIPT_CALL_VARIABLE_REFERENCE: '$' IDENTIFIER_START IDENTIFIER_END* -> type(IDENTIFIER);

SCRIPT_CALL_FLAG: '--' IDENTIFIER_START IDENTIFIER_END*;
SCRIPT_CALL_FLAG_GROUP: '-' IDENTIFIER_START IDENTIFIER_END*;

END_SCRIPT_CALL: (NEW_LINE | ')' | EOF) -> popMode;