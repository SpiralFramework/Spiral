package org.abimon.spiral.core.formats.models

import org.abimon.spiral.core.formats.SpiralFormat
import org.abimon.spiral.core.objects.game.DRGame
import org.abimon.spiral.core.objects.models.*
import org.abimon.spiral.core.readString
import org.abimon.spiral.core.utils.filterChunks
import org.abimon.spiral.mvc.gurren.Gurren
import java.io.InputStream
import java.io.OutputStream
import java.io.PrintStream

object GMOModelFormat: SpiralFormat {
    override val name: String = "GMO"
    override val extension: String? = "gmo"
    override val conversions: Array<SpiralFormat> = arrayOf(OBJModelFormat)

    override fun isFormat(game: DRGame?, name: String?, context: (String) -> (() -> InputStream)?, dataSource: () -> InputStream): Boolean = dataSource().use { stream -> stream.readString(12) == "OMG.00.1PSP\u0000" }

    override fun convert(game: DRGame?, format: SpiralFormat, name: String?, context: (String) -> (() -> InputStream)?, dataSource: () -> InputStream, output: OutputStream, params: Map<String, Any?>): Boolean {
        if(super.convert(game, format, name, context, dataSource, output, params)) return true

        val gmo = GMOModel(dataSource)
        when(format) {
            is OBJModelFormat -> {
                val out = PrintStream(output)

                val modelSurfaces = gmo.filterChunks(GMOModelSurfaceChunk::class)
                val names = gmo.filterChunks(GMOMaterialNameChunk::class)
                val materials = gmo.filterChunks(GMOMaterialChunk::class)

                out.println("# SPIRAL v${Gurren.version}")
                out.println("# Autogenerated")
                out.println()
                var addition: Int = 0
                modelSurfaces.forEachIndexed { index, modelSurface ->
                    val verts = modelSurface.subchunks.filterChunks(GMOVertexArrayChunk::class)
                    val meshes = modelSurface.subchunks.filterChunks(GMOMeshFacesChunk::class)
                    val floatChunks = modelSurface.subchunks.filterChunks(GMO8014Chunk::class)

                    meshes.distinctBy { mesh -> mesh.arIndex }.forEach { mesh ->
                        val vertChunk = verts[mesh.arIndex]
                        val floatChunk = floatChunks[mesh.arIndex]

                        out.println("g mesh$index")
                        vertChunk.uvs.forEach { (u, v) -> out.println("vt $u $v") }
                        vertChunk.vertices.forEach { (x, y, z) -> out.println("v $x $y $z") }
                    }

                    meshes.forEachIndexed { meshIndex, mesh ->
//                        when (mesh.primType) {
//                            3 ->
//                            4 -> mesh.faces.forEach { (a, b, c) ->
//                                out.println("f ${a + 1 + addition} ${b + 1 + addition} ${d + 1 + addition}")
//                                out.println("f ${c + 1 + addition} ${d + 1 + addition} ${b + 1 + addition}")
//                            }
//                        }

                        mesh.faces.forEach { (a, b, c) -> out.println("f ${a + 1 + addition} ${b + 1 + addition} ${c + 1 + addition}") }
                    }

                    meshes.distinctBy { mesh -> mesh.arIndex }.forEach { mesh ->
                        val vertChunk = verts[mesh.arIndex]
                        addition += vertChunk.vertices.size

                        out.println()
                    }
                }
            }
        }
        return true
    }
}